Hi!
Starting from React version 16.8, hooks have 
become a part of our everyday development. This
functionality has sparked a lot of debates, 
and there are reasons for it. In this video,
we will discuss one of the most common 
misconceptions about using hooks.
Let #39;s consider 2 options for writing a component. 
The first option is to use classes. In this
option, we added a method to the class, and 
when an instance of the class is created,
this method is created once, and in the render, 
we already use a reference to this method. Thus,
with each render, we always refer to the same 
reference and do not recreate the class method.
This construct was familiar and understandable 
to everyone who has been in the profession for
a long time, even if you recently came to 
React from another programming language.
The second way to create a component is 
by using a function. In this approach,
to create an onClick handler, we define the 
body of it directly inside the render because
the entire function body is the render 
itself. There is no other option if you
want to use props. And here is where we start 
to feel uncomfortable. How can it be that we
should create a new function on every render? It 
seems like a step backwards compared to classes.
To find out the answer on the question, 
I’ve opened legacy React documentation and
found the following question in the Q amp;A section:
Are Hooks slow because of 
creating functions in render?
No. In modern browsers, the raw performance of
closures compared to classes doesn’t differ 
significantly except in extreme scenarios.
In addition, consider that the design of 
Hooks is more efficient in a couple ways:
Hooks avoid a lot of the overhead that classes 
require, like the cost of creating class instances
and binding event handlers in the constructor.
Idiomatic code using Hooks doesn’t need the deep
component tree nesting that is prevalent in 
codebases that use higher-order components,
render props, and context. With smaller 
component trees, React has less work to do.
According to the documentation, creating a class 
instance for React is such an expensive operation
that creating a function for each render 
is orders of magnitude cheaper. Moreover,
the fact that the tree becomes deeper 
when using higher-order components like
Redux #39;s connect or MobX #39;s infinite 
observers is not pleasing at all.
This idea is a bit difficult for developers 
to accept because we are used to optimizing
everything, and now we need to make the code 
less optimized that it was with classes. And
as a result, we start looking for ways to get 
back to the previous level of optimizations.
And the first thing that is googled is 
to start using the useCallback hook. And
many people start actively using it in their 
projects
The question is only how well 
we understand how useCallback
works. Let #39;s conduct a small quiz for this:
In one case, we’ve created a component 
where it creates someFunction callback
on each render. And we call 
it when the button is clicked.
In the second case, we have 
exactly the same component,
but we’ve decided to wrap the callback in 
useCallback. For the user, nothing has changed,
console.log is still called 
when the button is clicked.
So, now the actual question. In which way 
someFunction callback created less frequently?
Take a minute to think.
And the correct answer is neither! Yes, exactly, 
useCallback did not give us any optimization,
the function is created exactly as many 
times as before the optimization. Moreover,
we actually worsened the 
performance of our component.
What can fool you is the perception that 
useCallback is some kind of black box where
you pass a callback, something happens 
with it, and then you have happiness. But
let #39;s consider how it actually works. First, 
let #39;s do a typeof check on this black box,
and naturally, we get function. 
It was obvious from the syntax.
To understand how the black box 
works, let #39;s write the useCallback
implementation ourselves. This is a function 
that takes 2 parameters: callback and deps.
Next, we need to store this callback 
and dependencies somewhere so that
we can return the same callback 
function on each subsequent call.
Now let #39;s consider different cases. If the 
dependencies do not exist either in prevState
or in the new data, then we need to save the 
current parameters and return the callback.
But if the dependencies exist, then 
we compare the arrays using a certain
function and if they match, we 
return the memoized function.
And if the dependencies do not match,
then we again save the parameters 
and return the current callback.
It seems like we have covered all the 
cases. What conclusions can we do from this?
The useCallback function, like any other function, 
is called on each render, and each render receives
a new function and a new array of dependencies as 
a callback parameter. Which we either throw away,
if the dependencies before and after are equal, 
or save them in the repository for future use
Let #39;s now look at this function from 
the component side. Now we know that
useCallback is just a function and we can 
extract the passed parameters into own
variables. Here it becomes quite obvious that 
we create not only a function for each render,
but also an array with dependencies, 
and then pass all this to use Callback.
If we just comment out the dependency creation 
and the useCallback call and pass the callback
parameter directly to onClick, then it seems that 
the performance of the component should improve,
because we have removed the intermediary, 
which was of no use to the performance.
To put an end to this story, let #39;s also remove the 
commented code and we end up back to the initial
situation. When we just create a function for each 
render. It turns out that in this case, using the
useCallback hook does not improve the performance, 
but rather the opposite - it worsens it.
It turns out that we are using useCallback 
incorrectly. To understand this, let #39;s refer to
the documentation. I decided to show you a piece 
of text from the legacy documentation. Because
it is better works for our video
Returns a memoized callback.
Pass an inline callback and an array of 
dependencies. useCallback will return
a memoized version of the callback that only 
changes if one of the dependencies has changed.
This is useful when passing callbacks to 
optimized child components that rely on
reference equality to prevent unnecessary 
renders (e.g. shouldComponentUpdate).
I.e., the main idea is not to improve the 
performance in a particular component,
but rather it is only beneficial if the callback 
is passed as props. Let #39;s look at another example.
Let #39;s say we have a list of cars that we want to 
display. We have a Cars component that receives
the list of cars via props and draws them one by 
one using the map method and the Car component.
Here we needed to add a handler for 
clicking on a car. We create the
onCarClick callback and pass it to the 
Car component. And in this situation,
for each render of the Cars component, we 
create a new instance of the onCarClick
callback. Respectively, no matter if Car 
is a PureComponent or wrapped in a memo,
all cars will always be re-rendered, because they 
get a new instance of the callback each time.
This is what useCallback is for, 
if we wrap the callback in a hook,
then we will have a memoized callback 
returned in the onCarClick variable,
even though we pass a new instance of the callback into useCallback for each render
Thus, all Car components will 
not be rendered unnecessarily,
because the reference to the 
callback will remain the same.
And if we look inside the Car component
There we will create another function
that will link onCarClick and the car object. 
In this case, there is no use of wrapping the
callback in useCallback, because we don #39;t care 
whether it is a reference to a callback from
the previous render or from the current render, 
and useCallback as we already know is not free
This video can be summarized in the following 
words. Although React supports components as
classes, it has more maneuvers over acceleration 
of components as functions. And the ecosystem
itself is increasingly providing you with hooks 
as APIs, which is impossible to use in classes.
And of course, trust react, if they said it #39;s 
better to create a callback for every render,
do it, because they are only interested in 
improving the performance of your project.
And if you liked our video, be sure to share 
the link with your colleagues, press the like
button and subscribe to the channel. There 
will be a lot more interesting things here.
Bye